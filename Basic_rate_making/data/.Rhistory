plot(x_kpca)
plt.plot(x_kpca)
plt.show()
pca = PCA()
print(type(x_kpca))
plt.scatter(x_kpca)
x_kpca.shape()
print(x_kpca)
print(x_kpca.shape())
print(x_kpca.shape
print(x_kpca.shape)
x_kpca = kpca.fit_transform(x)
kpca  = KernelPCA(kernel="rbf", fit_transform=True, gamma=10)
inverse_
kpca  = KernelPCA(kernel="rbf", fit_inverse_transform=True, gamma=10)
X_pca = pca.fit_transform(x)
X_pca.head()
print(x_kpca.shape[1])
X, _ = make_circles(n_samples= 1000, random_state=1, noise=0.1, factor=0.1)
X
plt.scatter(X)
_
X.shape
plt.scatter(x = X[0], y=[1])
plt.scatter(x = X[:,0], y=[:,1])
X[0]
X[1]
X[0,1]
X[:,1]
X[:,0]
len(X[:,0])
plt.scatter(x=X[:, 0], y=[:, 1])
sns.scatterplot(x=X[:,0], y=X[:,1])
plt.show()
sns.scatterplot(x=X[:,1], y=X[:,0])
plt.show()
sns.scatterplot(x=X[:,1], y=X[:,0])
plt.show()
'''
sns.pairplot(x_vars=["PC1"], y_vars=["PC2"], data=x_pca, hue='Target')
plt.show()
'''
X, _ = make_circles(n_samples= 1000, random_state=1, noise=0.1, factor=0.1)
sns.scatterplot(x=X[:,1], y=X[:,0])
plt.show()
sns.scatterplot(x=X[:,0], y=X[:,1])
plt.show()
plt.scatter(x=X[:,0], y=X[:,1])
plt.show()
X, _ = make_circles(n_samples= 1000, random_state=1, noise=0.1, factor=0.2)
plt.scatter(x=X[:,0], y=X[:,1])
plt.show()
X, _ = make_circles(n_samples= 1000, random_state=1, noise=0.1, factor=0.05)
plt.scatter(x=X[:,0], y=X[:,1])
plt.show()
X, _ = make_circles(n_samples= 1000, random_state=1, noise=0.1, factor=0.1)
sns.scatterplot(x=X[:,0], y=X[:,1])
plt.show()
kpca = KernelPCA(kernel='rbf', gamma=15, n_components=1)
x_kpca = kpca.fit_transform(X)
x_kpca.shape
from sklearn.datasets import make_moons
X, y = make_moons(n_samples=500, noise=0.2, random_state=1234)
plt.scatter(X[:,0], y[:1], c=y)
plt.scatter(X[:,0], y[:,1], c=y)
X, y = make_moons(n_samples = 500, noise = 0.02, random_state = 417)
plt.scatter(X[:, 0], X[:, 1], c = y)
plt.show()
dev.off()
# Clear Namespace
rm(list=ls())
# Create Dataset
A <- c(117.1, 121.3, 127.8, 121.9, 117.4, 124.5, 119.5, 115.1)
B <- c(123.5, 125.3, 126.5, 127.9, 122.1, 125.6, 129.8, 117.2)
dat <- data.frame(weight = c(A,B),
company = rep(c("A","B"), each=8))
# Generate Box Plot
boxplot(weight ~ company, data = dat)
# Run Wilcoxon Rank Sum Test
wilcox.test(weight ~ company, data = dat)
head(dat)
rt.data
rm(list=ls())
dev.off(dev.list()["RStudioGD"])
# IMPORT LIBRARIES
library(ggplot2)
library(DBI)
# Instantiate Connection to DB -------------------------
con <- dbConnect(odbc::odbc(),
Driver = "SQL Server",
Server = "yde2xj08jm.database.windows.net",
Database = "SwyfftAnalyticsCentral",
UID = "AnalyticsReadOnly ",
PWD = rstudioapi::askForPassword("Database password"),
port = 1433)
# Load Data ---------------------------------------------
rt.data <- dbGetQuery(con, '
SELECT [PolicyNumber], "Response Time"
FROM [dataiku].[PROFITABILITYCORE_frt_score_api_details_final]')
rt.data
# Clearn Namespace & Plots ------------------------------
rm(list=ls())
dev.off(dev.list()["RStudioGD"])
# IMPORT LIBRARIES
library(ggplot2)
library(DBI)
# Instantiate Connection to DB -------------------------
con <- dbConnect(odbc::odbc(),
Driver = "SQL Server",
Server = "yde2xj08jm.database.windows.net",
Database = "SwyfftAnalyticsCentral",
UID = "AnalyticsReadOnly ",
PWD = rstudioapi::askForPassword("Database password"),
port = 1433)
# Load Data ---------------------------------------------
rt.data <- dbGetQuery(con, '
SELECT [PolicyNumber], "Response Time"
FROM [dataiku].[PROFITABILITYCORE_frt_score_api_details_final]')
rt.data
# Load Data ---------------------------------------------
rt.data <- dbGetQuery(con, '
SELECT * FROM [dbo].[chris_core_claims_reclassification_manual_with_claim_type]')
rt.data <- dbGetQuery(con, '
SELECT * FROM [dbo].[chris_core_claims_reclassification_manual_with_claim_type]')
rt.data
rt.data <- dbGetQuery(con, '
SELECT * FROM [dbo].[chris_core_claims_reclassification_manual_with_claim_type]')
# Load Data ---------------------------------------------
rt.data <- dbGetQuery(con, '
SELECT [CLAIM_NBR/RES_NBR]
,[CLAIM_TYPE]
,[Claim_Type_Coverage_Group]
,[COVERAGE]
,[CAUSE_OF_LOSS]
,[PERIL]
,[SUB_PERIL]
,[ACC_DESC]
,[Covid_Flag]
FROM [dbo].[chris_core_claims_reclassification_manual_with_claim_type]')
# Load Data ---------------------------------------------
rt.data <- dbGetQuery(con, '
SELECT
CAST([CLAIM_NBR/RES_NBR] AS nvarchar(100))
,CAST([CLAIM_TYPE] AS varchar(100))
,CAST([Claim_Type_Coverage_Group] AS varchar(100))
,CAST([COVERAGE] AS varchar(100))
,CAST([CAUSE_OF_LOSS] AS varchar(100))
,CAST([PERIL] AS varchar(100))
,CAST([SUB_PERIL] AS varchar(100))
,CAST([ACC_DESC]AS varchar(250))
,[Covid_Flag]
FROM [dbo].[chris_core_claims_reclassification_manual_with_claim_type]')
require(XML)
install.packages('XML')
require(XML)
require(XML)
help(xmlTreeParse)
# Create Step Plot --------------------------------------------------
data("AirPassengers")
air <- AirPassengers
# Create Step Plot --------------------------------------------------
data("AirPassengers")
# Create Step Plot --------------------------------------------------
data("BJsales")
# Create Step Plot --------------------------------------------------
data("BJsales")
# Create Step Plot --------------------------------------------------
data()
# Create Step Plot --------------------------------------------------
data(AirPassengers)
head(AirPassengers)
length(AirPassengers)
seq(length(AirPassengers))
x.vals <- seq(length(AirPassengers))
# Create Step Plot --------------------------------------------------
y.values = data(AirPassengers)
y.vals <- AirPassengers
x.vals <- seq(length(AirPassengers))
plot(x.vals, y.vals)
plot(x.vals, y.vals, type='s')
plot(x.vals, type='hist')
hist(x.vals)
hist(x.vals, bins=10)
hist(x.vals, bins=10)
hist(x.vals, bins=100)
hist(x.vals, bins=5)
warnings()
help(hist)
help(hist, breaks=10)
hist(x.vals, breaks=10)
hist(x.vals, breaks=15)
hist(y.vals, breaks=15)
hist(y.vals, breaks=10)
hist(y.vals, breaks=10)
# Step 1 - create a sample from a normal distributoin with known mu and sigma2
my = <- 20; sigma.2 <- 4; set.seed(33)
# Step 1 - create a sample from a normal distributoin with known mu and sigma2
my <- 20; sigma.2 <- 4; set.seed(33)
# Step 1 - create a sample from a normal distributoin with known mu and sigma2
mu <- 20; sigma.2 <- 4; set.seed(33)
# Clear namespace and plots
rm(list=ls())
dev.off()
# Step 1 - create a sample from a normal distributoin with known mu and sigma2
mu <- 20; sigma.2 <- 4; set.seed(33)
X <- rnomr(100, mu, sqrt(sigma.2))
X <- rnorm(100, mu, sqrt(sigma.2))
hist(X)
X <- rnorm(1000, mu, sqrt(sigma.2))
hist(X)
qqnorm(X)
# Step 2 - Define L According to equation 9.2, which is for the normal distribution
log.L <- function(mu.hat = 15, simga2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) +
1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step 2 - Define L According to equation 9.2, which is for the normal distribution
log.L <- function(mu.hat = 15, simga2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) + 1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step3 - Use MLE Function from the Stats Packages
library(stats4)
(fit <- mle(log.L))
# Step 2 - Define L According to equation 9.2, which is for the normal distribution
log.L <- function(mu.hat = 15, simga.2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) + 1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step3 - Use MLE Function from the Stats Packages
library(stats4)
(fit <- mle(log.L))
log.L <- function(mu.hat = 15, simga.2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) + 1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step3 - Use MLE Function from the Stats Packages
library(stats4)
(fit <- mle(log.L))
# Step 2 - Define L According to equation 9.2, which is for the normal distribution
log.L <- function(mu.hat = 15, sigma.2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) + 1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step3 - Use MLE Function from the Stats Packages
library(stats4)
(fit <- mle(log.L))
X <- rnorm(100, mu, sqrt(sigma.2))
hist(X)    # hist plot
qqnorm(X)  # qq plot
log.L <- function(mu.hat = 15, sigma.2.hat = 6){
n <- length(X)
n/2 * log(2 * pi * sigma.2.hat) + 1/2 * sum((X - mu.hat)^2 / sigma.2.hat)
}
# Step3 - Use MLE Function from the Stats Packages
library(stats4)
(fit <- mle(log.L))
fit <- mle(log.L)
summary(fit)
f = makeFun(x^2+y~x&y)
library(mosaic)
install.packages(mosaic)
install.packages('mosaic')
library(makeFun)
library(mosaic)
f = makeFun(x^2+y~x&y)
print(f)
g = makeFun(x^2 - y^2 ~x&y)
print(g)
# Plot Objective Function
plotFun(f(x,y)~x&y)
# Plot Objective Function
plotFun(f(x,y)~x&y, x.lim=range(0,10), y.lim=range(0,10))
# Plot Objective Function
plotFun(f(x,y)~x&y, x.lim=range(-10,10), y.lim=range(-10,10))
# Not Plot the Constraint
plotFun(g(x,y)~x&y, levels=1, x.lim=range(-10,10), y.lim=range(-10,10)), filled=FALSE, add=TRUE,
color='red')
# Not Plot the Constraint
plotFun(g(x,y)~x&y, levels=1, x.lim=range(-10,10), y.lim=range(-10,10)), filled=FALSE, add=TRUE, color='red')
# Not Plot the Constraint
plotFun(g(x,y)~x&y, levels=1, x.lim=range(-10,10), y.lim=range(-10,10), filled=FALSE, add=TRUE, color='red')
# Plot Objective Function
plotFun(f(x,y)~x&y, x.lim=range(-10,10), y.lim=range(-10,10), filled=FALSE)
# Not Plot the Constraint
plotFun(g(x,y)~x&y, levels=1, x.lim=range(-10,10), y.lim=range(-10,10), filled=FALSE, add=TRUE, color='red')
dev.off()
# Plot Objective Function
plotFun(f(x,y)~x&y, x.lim=range(-2,2), y.lim=range(-2,2), filled=FALSE)
# Not Plot the Constraint
plotFun(g(x,y)~x&y, levels=1, filled=FALSE, add=TRUE, color='red')
setwd("C:\\Users\\chris.cirelli\\Desktop\\repositories\\gsu_fall_2020\\Basic_rate_making\\data")
# Clear Namespace
rm(list=ls())
# Read Data
read_table("lossdata.csv")
# Read Data
read.csv("lossdata.csv")
# Read Data
data <- read.csv("lossdata.csv")
head(data)
# Distribution
plot(data$Loss)
# Distribution
hist(data$Loss)
# Distribution
hist(data$Loss, bins=10)
# Distribution
hist(data$Loss)
help(hist)
help(hist, breaks=10)
# Distribution
hist(data$Loss, break=10)
# Distribution
hist(data$Loss, breaks=10)
# Distribution
hist(data$Loss, breaks=20)
# Distribution
hist(data$Loss, breaks=50)
# Distribution
hist(data$Loss, breaks=50, title='Loss Data')
# Distribution
hist(data$Loss, breaks=50, main='Loss Data')
# Distribution
hist(data$Loss, breaks=50, main='Loss Data', xlab='Count')
# Distribution
hist(data$Loss, breaks=50, main='Loss Data', xlab='Incurred Amount')
setwd("C:\\Users\\chris.cirelli\\Desktop\\repositories\\gsu_fall_2020\\Basic_rate_making\\data")
# Import Packages
library(dplyr)
library(DBI)
library(readxl)
library(fitdistrplus)
# Fit Distribution To Data
plot.dist(data$Loss)
# Fit Distribution To Data
plotdist(data$Loss)
# Fit Distribution To Data
plotdist(data$Loss, main='Loss Data')
# Fit Distribution To Data
plotdist(data$Loss, histo=TRUE, demp=TRUE)
descdist(data$loss, boot=True)
descdist(data$loss, boot=1000)
descdist(data$Loss, boot=1000)
descdist(data$Loss, boot=1000)
colnames(data)
col.names <_ colnames(data)
col.names <- colnames(data)
col.names
# Distribution ALAE
hist(data$ALAE, breaks=50, main='ALAE', xlab='ALAE')
plotdist(data$ALAE, histo=TRUE, demp=TRUE)
# Distribution ALAE
hist(data$ALAE, breaks=50, main='ALAE', xlab='ALAE')
plotdist(data$ALAE, histo=TRUE, demp=TRUE)
descdist(data$ALAE, boot=1000)
plotdist(data$ALAE, histo=TRUE, demp=TRUE)
d.gamma <- fitdist(data$Loss, discrete=FALSE, "gamma", method='mle')
d.gamma <- fitdist(data$Loss/100, discrete=FALSE, "gamma", method='mle')
d.gamma <- fitdist(data$Loss/1000000, discrete=FALSE, "gamma", method='mle')
d.gamma
summary(d.gamma)
# Parameters
alpha = .506
beta  = 1/ 0..0152
mu = alpha * beta
beta  = 1/ 0.0152
mu = alpha * beta
std.dv = sqrt(alpha * beta ^2)
range = seq(0, mu + 10 * std.dv, 0.2)
# Draw Gamma Distribution
y = dgamma(x = range, shape = alpha, rate = 1/beta)
plot(range, y, type='l', main='Gamma Distribution Fit 2 Loss Data',
xlab = 'incurred (per 100,000)', ylab = 'percentage')
loss <- data$Loss
loss
library(Hmisc)
library(skimr)
# Create Data Dict
col.names <- colnames(data)
skm <- skim(data)
hd <- data.frame(t(head(data)))
hd$colnames <- col.names
mrg <- merge(x=skm, y=hd, by.x = 'skim_variable', by.y='colnames')
mrg
mrg <- merge(x=skm, y=hd, by.x = 'skim_variable', by.y='colnames')
write_xlsx(mrg, paste('data_dict_', i, '_', test[i], '.xlsx'))
library(writexl)
write_xlsx(mrg, paste('data_dict_', i, '_', test[i], '.xlsx'))
write_xlsx(mrg, paste('data_dict.xlsx'))
lenght(loss)
length(loss)
loss_1000 <- data[1:1000]
loss_1000 <- loss[1:1000]
lenght(loss_1000)
length(loss_1000)
loss_1500 <_ loss[loss_1000:]
loss_1500 <- loss[loss_1000:]
loss_1000 <- loss[1:1000]
loss_1500 <- loss[loss_1000:]
loss_1500 <- loss[loss_1000:1500]
loss_1k <- loss[1:1000]
loss.1.0k <- loss[1:1000]
loss.1.5k <- loss[length(loss.1.0k):]
loss.1.5k <- loss[length(loss.1.0k):1500]
length(loss.1.5k)
length(loss.1.0k)
loss.1.5k <- loss[length(loss.1.0k)-1:1500]
loss.1.5k <- loss[1001:1500]
length(loss.1.5k)
test <- c(1,2,3)
replace(test, x, 1)
replace(test, test, 1)
replace(test, test>3, 1)
# Apply Caps
loss.1.0k.capped <- replace(loss.1.0k, loss.1.0k > 5000, 5000)
hist(loss.1.0k.capped)
hist(loss.1.0k)
plotdist(loss.1.0k)
plotdist(loss.1.0k.capped)
plotdist(loss.1.0k.capped)
plotdist(loss.1.0k)
plotdist(loss.1.0k.capped)
loss.1.5k.capped <- replace(loss.1.5k, loss.1.0k > 25000, 25000)
hist(loss.1.5k.capped)
test <- c(loss.1.0k.capped, loss.1.5k.capped)
hist(test)
length(test)
loss.1.0k <- loss[1:1000]
loss.1.5k <- loss[1001:1500]
# Apply Caps
loss.1.0k.capped <- replace(loss.1.0k, loss.1.0k > 5000, 5000)
loss.1.5k.capped <- replace(loss.1.5k, loss.1.0k > 25000, 25000)
test <- c(loss.1.0k.capped, loss.1.5k.capped)
length(test)
length(loss.1.0k)
length(loss.1.5k)
length(loss.1.0k.capped)
length(loss.1.5k.capped)
loss.1.5k.capped <- replace(loss.1.5k, loss.1.5k > 25000, 25000)
test <- c(loss.1.0k.capped, loss.1.5k.capped)
hist(test)
test
loss.capped <- c(loss.1.0k.capped, loss.1.5k.capped)
# Plot Capped Losses
plotdist(loss.capped)
install.packages('logger')
library(logger)
log_threshold(DEBUG)
log_info('Test')
log_warn(('Warn'))
log_info('Info')
log_threshold(DEBUG)
log_layout(layout_glue_colors)
log_threshold(TRACE)
log_info('Info')
log_error('Error')
log_warn(('Warn'))
log_info('Info')
log_error('Error')
log_warn(('Warn'))
require("ggplot2")
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy, color = class))
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy, size = class))
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~ class, nrow = 2)
?ggplot
?facet_wrap
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ cyl)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~ class, nrow = 2)
head(mpg)
mpg$class
set(mpg$class)
unique(mpg$class)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(drv ~ cyl)
s or columns dimension, use a . instead of a variable name
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_grid(. ~ cyl)
o the following:
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy)) +
facet_wrap(~ cyl, nrow = 1)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg) +
geom_smooth(mapping = aes(x = displ, y = hwy))
x = seq(0, 10, 1)
x
x = runif(3, min=0, max=100)
x
y = runif(100, min=0, max=100)
ggplot() + geom_smooth(mapping=aes(x=x, y=x))
ggplot() + geom_smooth(mapping=aes(x=x, y=x))
plot(x, y)
x = runif(100, min=0, max=100)
y = runif(100, min=0, max=100)
length(x)
length(y)
plot(x, y)
